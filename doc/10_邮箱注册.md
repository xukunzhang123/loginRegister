# 邮箱注册

## 发送邮件功能测试
https://docs.djangoproject.com/zh-hans/4.2/topics/email/
登录自己的网易邮箱，设置POP、SMTP等的信息，开启SMTP服务，记录登录码　“CTQNCQXKBCYHISEA“
SMTP服务器: smtp.163.com  默认是25端口。POP3/SMTP/IMAP服务全部支持SSL连接

进入到　loginRegister/settings.py　配置邮件

```python
# mail config
EMAIL_HOST = "smtp.163.com"
EMAIL_PORT = 25
EMAIL_HOST_USER = "xukunzhang1@163.com"
EMAIL_HOST_PASSWORD = "CTQNCQXKBCYHISEA"
#EMAIL_USE_TLS
EMAIL_USE_SSL = False
```
交互式环境中测试发送邮件是否成功？ 
输入 python.exe .\manage.py shell
In [1]: from django.core.mail import send_mail
In [2]: help(send_mail)
In [3]: from loginRegister.settings import EMAIL_HOST_USER
In [4]: send_mail("测试邮件","content body",EMAIL_HOST_USER,['xukunzhang1@163.com','1002723982@qq.com'])    
Out[4]: 1
In [5]: send_mail("测试邮件","content body",EMAIL_HOST_USER,['1002723982@qq.com'])
Out[5]: 1

In [6]: send_mail("测试邮件","content body",EMAIL_HOST_USER,['xukunzhang1@163.com'])
Out[6]: 1

验证邮箱是否收到邮件
测试时不能只发送给自己的邮箱。

## 基本注册功能实现
### 注册表单
login/forms.py
```python
class RegisterForm(forms.Form):
    username = forms.CharField(label="用户名", required=True, max_length=128)
    password1 = forms.CharField(label="密码", required=True, max_length=10)
    password2 = forms.CharField(label="密码", required=True, max_length=10)
    email = forms.EmailField(label="邮箱地址")
    captcha = CaptchaField(label="验证码")
```
### 实现注册视图
如果用户已经登录，则不能注册跳转至首页
如果是GET请求，返回用户注册的html页面
如果是POST请求，先验证提交的数据是否通过，清洗数据，接下来判断用户名和邮箱是否已经被注册，将注册的数据存储到数据库，跳转到登录页面
额外功能：为了数据的安全性，注册时密码存储到数据库不是明文，而是先加密后存储

login/views.py
```python
from login.forms import LoginForm, RegisterForm

def register(request):
    # 如果用户已经登录，则不能注册跳转到首页
    if request.session.get('is_login',None):
        return redirect('/index/')

    #如果是POST请求，先验证提交的数据是否通过，
    if request.method == 'POST':
        print(request.POST)
        register_form = RegisterForm(request.POST)
        message = "请检查你填写的内容！"
        #print(message)
        #清洗数据
        if register_form.is_valid():
            username = register_form.cleaned_data.get('username')
            password1 = register_form.cleaned_data.get('password1')
            password2 = register_form.cleaned_data.get('password2')
            email = register_form.cleaned_data.get('email')
            #接下来判断用户名和邮箱是否已经被注册，跳转到登录页面
            print(locals())
            same_name_user = SiteUser.objects.filter(name=username)
            if same_name_user:
                message = "用户名已经存在！"
                return render(request,'login/register.html',locals())
            same_email_user = SiteUser.objects.filter(email=email)
            print(same_email_user)
            if same_email_user:
                message = "该邮箱已经被注册了！"
                return render(request,'login/register.html',locals())
            #将注册的数据存储到数据库，跳转到登录页面
            new_suer = SiteUser(name=username,passwoed=password1,email=email)
            new_suer.save()
            return redirect('/login/')
    #如果是GET请求，返回用户注册的html页面
    register_form = RegisterForm()
    return render(request, 'login/register.html', locals())
```

### Templates 模板的更改
templates/login/register.html
```python
{% if register_form.captcha.errors %}
    <div class="alert alert-warning" role="alert">
        <strong>注册失败!</strong> 验证码不正确
    </div>
{% elif message %}
    <div class="alert alert-warning" role="alert">
        <strong>注册失败!</strong> {{ message }}
    </div>
{% endif %}

<form action="/register/" method="post">
    {% csrf_token %}
    <div class="form-group">
        <label> {{ register_form.username.label }} </label>
        <input type="text" class="form-control"  name="username">
    </div>
    <div class="form-group">
        <label>{{ register_form.email.label }}</label>
        <input type="email" class="form-control"  name="email">
    </div>
    <div class="form-group">
        <label>{{ register_form.password1.label }}</label>
        <input type="password" class="form-control"  name="password1">
        <small class="form-text text-muted">密码必须是字母、数字和特殊符号组成.</small>
    </div>
    <div class="form-group">
        <label>{{ register_form.password2.label }}</label>
        <input type="password" class="form-control"  name="password2">
        <small class="form-text text-muted">密码必须是字母、数字和特殊符号组成.</small>
    </div>
    <div class="form-group">
        <label>{{ register_form.captcha.label }}</label>
        {{ register_form.captcha }}
    </div>
    <!-- float-right 将按钮飘到右侧 -->
    <!-- a 标签是添加链接，<ins>新用户注册</ins> 为标签添加下划线 class="text-success" 控制颜色success绿色，error红色-->
    <a href="/login/" class="text-success">
        <ins>用户登录</ins>
    </a>
    <button type="submit" class="btn btn-primary float-right">注册</button>
</form>
```

## 注册添加密码加密功能
对于如何加密密码，有很多种不同的方式，其安全程度也高低不等。这里我们使用python 内置的hashlib库，使用哈希值的方式加密密码，可能安全等级不高，但简单使用方便。

· 在login/utils.py 中编写一个hash函数：

```python
import hashlib

def hash_code(s, salt='mysite'): #加点盐
    h = hashlib.sha256()
    s += salt
    h.update(s.encode(utf-8))  #update方法只接收bytes类型
    return h.hexdigest()
```
· 在login/views.py 中修改login和register视图
```python
from login.utils import hash_code

def login(request):
            ...
            user = SiteUser.objects.filter(name=username, passwoed=hash_code(password)).first()
            if user:
            ...
def register(request):
            ...
            new_suer = SiteUser(name=username,passwoed=hash_code(password1),email=email)
            ...
```

## 邮箱注册确认
很自然的，我们会想到如果能用邮件确认的方式对新注册的用户进行审查，即安全又正式，也是目前很多站点的做法。

### 创建模型
既然要区分通过和未通过邮件确认的用户，那么必须给用户添加一个是否进行过邮件确认的属性。
另外，要创建一张新表，用于保存用户的确认码以及注册提交的时间。
· login/models.py

```python
class SiteUser(models.Model):
    ...
    has_confirmed = models.BooleanField(default=False, verbose_name="是否邮箱验证")
    ...

class ConfirmString(models.Model):  #字符串确认表
    code = models.CharField(max_length=256, verbose_name="确认码")
    user = models.OneToOneField('SiteUser', on_delete=models.CASCADE)   #将用户和上面的用户进行关联，做到级联删除
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")  #创建的时候自动生成，后面更改不会变化

    def __str__(self):
        # 字符串友好展示
        return self.user.name + ":" + self.code

    class Meta:
        # 最先生成的确认码在最前面
        ordering = ["-create_time"]
        verbose_name = "确认码"
        verbose_name_plural = "确认码"
```
数据库模型的更改，一定要生成迁移脚本和写入数据库
python manage.py makemigrations
python manage.py migrate

修改后台模型，方便在后台修改和观察数据
login/admin.py
```python
from login.models import SiteUser, ConfirmString

admin.site.register(ConfirmString)
```

### 修改视图
· 封装一个对象方法用来生成字符串确认码
login/urls.py
```python
import  datetime
from login.models import ConfirmString

def make_confirm_string(user):
    # 获取当前时间
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    #2023-06-11 11:32:59
    code = hash_code(user.name, now)
    ConfirmString.objects.create(code=code, user=user)
    return code
```
· 封装一个发送邮件的对象方法，传入两个参数，分别是注册的邮箱和前面生成的哈希值
```python
from loginRegister import settings
from django.core.mail import send_mail
def send_email(email, code):
    print('send mail ......')
    subject = '注册确认邮箱'
    text_content = '''感谢注册，这里是登录系统注册网站！\
    如果你看到这个消息，说明您的邮箱服务器不提供HTML链接功能，请联系管理员！'''
    html_content = '''
    <p>感谢注册<a href="http://{}/confirm/?code={}" target=blank>点击认证</a>,\
    这里是登录注册系统网站！</p>
    <p>请点击站点链接完成注册确认</p>
    <p>此链接有效期为{}天！</p>
    '''.format('127.0.0.1:8888', code, settings.CONFIRM_DAYS)

    send_mail(subject, text_content, settings.EMAIL_HOST_USER, [email,],
              html_message = html_content )
```
其中最后的有效期天数在loginRegister/settings.py 中进行设置
CONFIRM_DAYS = 3

### 处理邮箱确认请求
login/utils.py 文件中进行确认
```python
from login.utils import hash_code, make_confirm_string, send_email

def register(request):
    ...
if same_email_user:
    message = "该邮箱已经被注册了！"
    return render(request, 'login/register.html', locals())
try:
    # 将注册的数据存储到数据库，跳转到登录页面
    new_suer = SiteUser(name=username, passwoed=hash_code(password1), email=email)
    new_suer.save()
    # 生成邮件确认码并发送邮件确认
    code = make_confirm_string(new_suer)
    send_email(email, code)
    message = '请前往邮箱进行确认!'
except  Exception:
    new_suer.delete()
    message = "发送邮件失败！"
    return render(request, 'login/register.html', locals())
else:
    return redirect('/login/')
# 如果是GET请求，返回用户注册的html页面
```
测试：注册一个用户，判断是否能收到确认邮件。

### 修改登录规则